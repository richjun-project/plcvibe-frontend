/**
 * Exports ladder logic to various PLC code formats
 */
import type { LadderProgram, LadderRung, LadderElement } from './parser'

export type ExportFormat = 'text' | 'structured-text' | 'instruction-list' | 'siemens-scl' | 'rockwell-st'

/**
 * Export ladder program to Structured Text (IEC 61131-3)
 */
export function exportToStructuredText(program: LadderProgram): string {
  const lines: string[] = []

  lines.push('(* ========================================= *)')
  lines.push('(* PLC Ladder Logic - IEC 61131-3 Format   *)')
  lines.push('(* Generated by PLCVibe                     *)')
  lines.push('(* Standard: Structured Text (ST)           *)')
  lines.push('(* ========================================= *)')
  lines.push('')

  // Collect all variables
  const inputs = new Set<string>()
  const outputs = new Set<string>()
  const memory = new Set<string>()
  const analogInputs = new Set<string>()
  const analogOutputs = new Set<string>()
  const memoryWords = new Set<string>()
  const timers = new Map<string, number>() // address -> preset
  const counters = new Map<string, number>() // address -> preset

  // Helper to collect addresses from elements
  const collectAddress = (addr: string | undefined) => {
    if (!addr) return
    const cleanAddr = addr.replace(/[\[\]\/\s]/g, '').split('.')[0]

    if (cleanAddr.startsWith('AI')) {
      analogInputs.add(cleanAddr)
    } else if (cleanAddr.startsWith('AQ')) {
      analogOutputs.add(cleanAddr)
    } else if (cleanAddr.match(/^MW\d+$/)) {
      memoryWords.add(cleanAddr)
    } else if (cleanAddr.startsWith('I')) {
      inputs.add(cleanAddr)
    } else if (cleanAddr.startsWith('Q')) {
      outputs.add(cleanAddr)
    } else if (cleanAddr.startsWith('M')) {
      memory.add(cleanAddr)
    }
  }

  program.networks.forEach(network => {
    network.elements.forEach(el => {
      // Collect from address field
      if (el.address) {
        const cleanAddr = el.address.replace(/[\[\]\/\s]/g, '').split('.')[0]

        if (cleanAddr.startsWith('T')) {
          if (el.type === 'timer' && el.preset) {
            timers.set(cleanAddr, el.preset)
          } else if (!timers.has(cleanAddr)) {
            timers.set(cleanAddr, 1000) // default
          }
        } else if (cleanAddr.startsWith('C')) {
          if (el.type === 'counter' && el.preset) {
            counters.set(cleanAddr, el.preset)
          } else if (!counters.has(cleanAddr)) {
            counters.set(cleanAddr, 10) // default
          }
        } else {
          collectAddress(el.address)
        }
      }

      // Collect from operands (for comparisons and math)
      collectAddress(el.operand1)
      collectAddress(el.operand2)
      collectAddress(el.result)
    })
  })

  // PROGRAM declaration
  lines.push('PROGRAM Main')
  lines.push('')

  // VAR_INPUT section
  if (inputs.size > 0 || analogInputs.size > 0) {
    lines.push('VAR_INPUT')

    // Digital inputs
    Array.from(inputs).sort().forEach(addr => {
      const ioInfo = program.ioMap.find(io => io.address === addr)
      lines.push(`  ${addr.replace('.', '_')} : BOOL; (* ${ioInfo?.description || 'Digital Input'} *)`)
    })

    // Analog inputs
    Array.from(analogInputs).sort().forEach(addr => {
      const ioInfo = program.ioMap.find(io => io.address === addr)
      lines.push(`  ${addr.replace('.', '_')} : REAL; (* ${ioInfo?.description || 'Analog Input'} *)`)
    })

    lines.push('END_VAR')
    lines.push('')
  }

  // VAR_OUTPUT section
  if (outputs.size > 0 || analogOutputs.size > 0) {
    lines.push('VAR_OUTPUT')

    // Digital outputs
    Array.from(outputs).sort().forEach(addr => {
      const ioInfo = program.ioMap.find(io => io.address === addr)
      lines.push(`  ${addr.replace('.', '_')} : BOOL; (* ${ioInfo?.description || 'Digital Output'} *)`)
    })

    // Analog outputs
    Array.from(analogOutputs).sort().forEach(addr => {
      const ioInfo = program.ioMap.find(io => io.address === addr)
      lines.push(`  ${addr.replace('.', '_')} : REAL; (* ${ioInfo?.description || 'Analog Output'} *)`)
    })

    lines.push('END_VAR')
    lines.push('')
  }

  // VAR section (internal variables, timers, counters)
  if (memory.size > 0 || memoryWords.size > 0 || timers.size > 0 || counters.size > 0) {
    lines.push('VAR')

    // Memory bits
    Array.from(memory).sort().forEach(addr => {
      const ioInfo = program.ioMap.find(io => io.address === addr)
      lines.push(`  ${addr.replace('.', '_')} : BOOL; (* ${ioInfo?.description || 'Memory Bit'} *)`)
    })

    // Memory words (for calculations)
    Array.from(memoryWords).sort().forEach(addr => {
      const ioInfo = program.ioMap.find(io => io.address === addr)
      lines.push(`  ${addr.replace('.', '_')} : REAL; (* ${ioInfo?.description || 'Memory Word'} *)`)
    })

    // Timers
    Array.from(timers.keys()).sort().forEach(addr => {
      const ioInfo = program.ioMap.find(io => io.address === addr)
      lines.push(`  ${addr} : TON; (* ${ioInfo?.description || 'Timer On-Delay'} *)`)
    })

    // Counters
    Array.from(counters.keys()).sort().forEach(addr => {
      const ioInfo = program.ioMap.find(io => io.address === addr)
      lines.push(`  ${addr} : CTU; (* ${ioInfo?.description || 'Count Up'} *)`)
    })

    lines.push('END_VAR')
    lines.push('')
  }

  // Program body
  program.networks.forEach((network, idx) => {
    lines.push(`(* Network ${idx + 1}${network.label ? ': ' + network.label : ''} *)`)

    const stCode = convertRungToStructuredText(network)
    if (stCode.trim()) {
      lines.push(stCode)
    }
    lines.push('')
  })

  lines.push('END_PROGRAM')

  return lines.join('\n')
}

function convertRungToStructuredText(rung: LadderRung): string {
  const elements = rung.elements

  // Build condition expression from contacts
  const conditions: string[] = []
  const outputs: Array<{type: string, address: string, preset?: number, operand1?: string, operand2?: string, value?: number}> = []

  elements.forEach(el => {
    switch (el.type) {
      case 'contact-no':
        if (el.address!.includes('.DN')) {
          const timerAddr = el.address!.replace(/[\[\]\s]/g, '').split('.')[0]
          conditions.push(`${timerAddr}.Q`)
        } else {
          conditions.push(el.address!.replace('.', '_'))
        }
        break

      case 'contact-nc':
        if (el.address!.includes('.DN')) {
          const timerAddr = el.address!.replace(/[\[\]\/\s]/g, '').split('.')[0]
          conditions.push(`NOT ${timerAddr}.Q`)
        } else {
          conditions.push(`NOT ${el.address!.replace('.', '_')}`)
        }
        break

      case 'coil':
      case 'coil-set':
      case 'coil-reset':
        outputs.push({type: el.type, address: el.address!})
        break

      case 'timer':
        outputs.push({type: 'timer', address: el.address!, preset: el.preset})
        break

      case 'counter':
        outputs.push({type: 'counter', address: el.address!, preset: el.preset})
        break

      // Comparison operators
      case 'compare-gt':
      case 'compare-lt':
      case 'compare-eq':
      case 'compare-ge':
      case 'compare-le':
      case 'compare-ne':
        if (el.operand1 && el.value !== undefined) {
          let op = '?'
          switch (el.type) {
            case 'compare-gt': op = '>'; break
            case 'compare-lt': op = '<'; break
            case 'compare-eq': op = '='; break
            case 'compare-ge': op = '>='; break
            case 'compare-le': op = '<='; break
            case 'compare-ne': op = '<>'; break
          }
          conditions.push(`${el.operand1.replace('.', '_')} ${op} ${el.value}`)
        }
        break

      // Math operations
      case 'math-add':
      case 'math-sub':
      case 'math-mul':
      case 'math-div':
      case 'move':
        outputs.push({
          type: el.type,
          address: el.result || '',
          operand1: el.operand1,
          operand2: el.operand2,
          value: el.value
        })
        break
    }
  })

  const lines: string[] = []

  // Build the enable condition for timers/counters
  const enableCondition = conditions.length > 0 ? conditions.join(' AND ') : 'TRUE'

  // Generate code for timers and counters (always execute)
  outputs.forEach(output => {
    if (output.type === 'timer') {
      lines.push(`${output.address}(IN := ${enableCondition}, PT := T#${output.preset}ms);`)
    } else if (output.type === 'counter') {
      lines.push(`${output.address}(CU := ${enableCondition}, PV := ${output.preset});`)
    }
  })

  // Generate IF statement for coils if there are conditions
  const coilOutputs = outputs.filter(o => o.type === 'coil' || o.type === 'coil-set' || o.type === 'coil-reset')

  if (coilOutputs.length > 0) {
    if (conditions.length > 0) {
      lines.push(`IF ${enableCondition} THEN`)

      coilOutputs.forEach(output => {
        switch (output.type) {
          case 'coil':
            lines.push(`  ${output.address.replace('.', '_')} := TRUE;`)
            break

          case 'coil-set':
            lines.push(`  ${output.address.replace('.', '_')} := TRUE; (* SET - Latch ON *)`)
            break

          case 'coil-reset':
            lines.push(`  ${output.address.replace('.', '_')} := FALSE; (* RESET - Force OFF *)`)
            break
        }
      })

      // Add ELSE for normal coils (not SET/RESET)
      const hasNormalCoils = coilOutputs.some(o => o.type === 'coil')
      if (hasNormalCoils) {
        lines.push('ELSE')
        coilOutputs.forEach(output => {
          if (output.type === 'coil') {
            lines.push(`  ${output.address.replace('.', '_')} := FALSE;`)
          }
        })
      }

      lines.push('END_IF;')
    } else {
      // No conditions - unconditional output
      coilOutputs.forEach(output => {
        switch (output.type) {
          case 'coil':
            lines.push(`${output.address.replace('.', '_')} := TRUE;`)
            break

          case 'coil-set':
            lines.push(`${output.address.replace('.', '_')} := TRUE; (* SET *)`)
            break

          case 'coil-reset':
            lines.push(`${output.address.replace('.', '_')} := FALSE; (* RESET *)`)
            break
        }
      })
    }
  }

  // Math operations (execute conditionally if there are conditions)
  const mathOutputs = outputs.filter(o => o.type === 'math-add' || o.type === 'math-sub' || o.type === 'math-mul' || o.type === 'math-div' || o.type === 'move')

  if (mathOutputs.length > 0 && conditions.length > 0) {
    // Conditional execution already handled above in coilOutputs
    if (coilOutputs.length === 0) {
      lines.push(`IF ${enableCondition} THEN`)
      mathOutputs.forEach(output => {
        const mathCode = generateMathOperationCode(output)
        if (mathCode) lines.push(`  ${mathCode}`)
      })
      lines.push('END_IF;')
    } else {
      // Add to existing IF block
      const lastIfIdx = lines.lastIndexOf('END_IF;')
      if (lastIfIdx !== -1) {
        mathOutputs.forEach(output => {
          const mathCode = generateMathOperationCode(output)
          if (mathCode) lines.splice(lastIfIdx, 0, `  ${mathCode}`)
        })
      }
    }
  } else if (mathOutputs.length > 0) {
    // Unconditional math operations
    mathOutputs.forEach(output => {
      const mathCode = generateMathOperationCode(output)
      if (mathCode) lines.push(mathCode)
    })
  }

  return lines.join('\n')
}

function generateMathOperationCode(output: {type: string, address: string, operand1?: string, operand2?: string, value?: number}): string | null {
  const dest = output.address.replace('.', '_')
  const op1 = output.operand1?.replace('.', '_') || '0'
  const op2 = output.operand2?.replace('.', '_') || output.value?.toString() || '0'

  switch (output.type) {
    case 'math-add':
      return `${dest} := ${op1} + ${op2};`
    case 'math-sub':
      return `${dest} := ${op1} - ${op2};`
    case 'math-mul':
      return `${dest} := ${op1} * ${op2};`
    case 'math-div':
      return `${dest} := ${op1} / ${op2};`
    case 'move':
      return `${dest} := ${op1};`
    default:
      return null
  }
}

/**
 * Export ladder program to Instruction List (IEC 61131-3)
 */
export function exportToInstructionList(program: LadderProgram): string {
  const lines: string[] = []

  lines.push('(* PLC Ladder Logic - Instruction List Format *)')
  lines.push('(* Generated by PLCVibe *)')
  lines.push('')

  program.networks.forEach((network, idx) => {
    lines.push(`(* Network ${idx + 1}${network.label ? ': ' + network.label : ''} *)`)

    const ilCode = convertRungToInstructionList(network)
    lines.push(ilCode)
    lines.push('')
  })

  return lines.join('\n')
}

function convertRungToInstructionList(rung: LadderRung): string {
  const lines: string[] = []
  let isFirstContact = true

  rung.elements.forEach((el, idx) => {
    switch (el.type) {
      case 'contact-no':
        const noAddr = el.address!.includes('.DN')
          ? el.address!.replace(/[\[\]\s]/g, '').split('.')[0] + '.Q'
          : el.address!.replace('.', '_')

        if (isFirstContact) {
          lines.push(`LD ${noAddr}`)
          isFirstContact = false
        } else {
          lines.push(`AND ${noAddr}`)
        }
        break

      case 'contact-nc':
        const ncAddr = el.address!.includes('.DN')
          ? el.address!.replace(/[\[\]\/\s]/g, '').split('.')[0] + '.Q'
          : el.address!.replace('.', '_')

        if (isFirstContact) {
          lines.push(`LDN ${ncAddr}`)
          isFirstContact = false
        } else {
          lines.push(`ANDN ${ncAddr}`)
        }
        break

      case 'coil':
        lines.push(`ST ${el.address!.replace('.', '_')}`)
        break

      case 'coil-set':
        lines.push(`S ${el.address!.replace('.', '_')}`)
        break

      case 'coil-reset':
        lines.push(`R ${el.address!.replace('.', '_')}`)
        break

      case 'timer':
        lines.push(`CAL ${el.address}(IN := TRUE, PT := T#${el.preset}ms)`)
        break

      case 'counter':
        lines.push(`CAL ${el.address}(CU := TRUE, PV := ${el.preset})`)
        break

      // Comparison operators - use boolean logic
      case 'compare-gt':
        if (isFirstContact) {
          lines.push(`LD ${el.operand1?.replace('.', '_')}`)
          lines.push(`GT ${el.value}`)
          isFirstContact = false
        } else {
          lines.push(`LD ${el.operand1?.replace('.', '_')}`)
          lines.push(`GT ${el.value}`)
          lines.push(`AND`)
        }
        break
      case 'compare-lt':
        if (isFirstContact) {
          lines.push(`LD ${el.operand1?.replace('.', '_')}`)
          lines.push(`LT ${el.value}`)
          isFirstContact = false
        } else {
          lines.push(`LD ${el.operand1?.replace('.', '_')}`)
          lines.push(`LT ${el.value}`)
          lines.push(`AND`)
        }
        break
      case 'compare-eq':
        if (isFirstContact) {
          lines.push(`LD ${el.operand1?.replace('.', '_')}`)
          lines.push(`EQ ${el.value}`)
          isFirstContact = false
        } else {
          lines.push(`LD ${el.operand1?.replace('.', '_')}`)
          lines.push(`EQ ${el.value}`)
          lines.push(`AND`)
        }
        break

      // Math operations
      case 'math-add':
        lines.push(`LD ${el.operand1?.replace('.', '_')}`)
        lines.push(`ADD ${el.operand2?.replace('.', '_') || el.value}`)
        lines.push(`ST ${el.result?.replace('.', '_')}`)
        break
      case 'math-sub':
        lines.push(`LD ${el.operand1?.replace('.', '_')}`)
        lines.push(`SUB ${el.operand2?.replace('.', '_') || el.value}`)
        lines.push(`ST ${el.result?.replace('.', '_')}`)
        break
      case 'math-mul':
        lines.push(`LD ${el.operand1?.replace('.', '_')}`)
        lines.push(`MUL ${el.operand2?.replace('.', '_') || el.value}`)
        lines.push(`ST ${el.result?.replace('.', '_')}`)
        break
      case 'math-div':
        lines.push(`LD ${el.operand1?.replace('.', '_')}`)
        lines.push(`DIV ${el.operand2?.replace('.', '_') || el.value}`)
        lines.push(`ST ${el.result?.replace('.', '_')}`)
        break
      case 'move':
        lines.push(`LD ${el.operand1?.replace('.', '_') || el.value}`)
        lines.push(`ST ${el.result?.replace('.', '_')}`)
        break
    }
  })

  return lines.join('\n')
}

/**
 * Export ladder program to Siemens SCL (Structured Control Language)
 */
export function exportToSiemensSCL(program: LadderProgram): string {
  const lines: string[] = []

  lines.push('(* ========================================= *)')
  lines.push('(* Siemens S7-1200/1500 SCL Format         *)')
  lines.push('(* Generated by PLCVibe                     *)')
  lines.push('(* ========================================= *)')
  lines.push('')

  lines.push('FUNCTION_BLOCK "Main_FB"')
  lines.push('{ S7_Optimized_Access := \'TRUE\' }')
  lines.push('')

  // Collect variables (same as ST)
  const inputs = new Set<string>()
  const outputs = new Set<string>()
  const memory = new Set<string>()
  const timers = new Map<string, number>()
  const counters = new Map<string, number>()

  program.networks.forEach(network => {
    network.elements.forEach(el => {
      if (el.address) {
        const cleanAddr = el.address.replace(/[\[\]\/\s]/g, '').split('.')[0]
        if (cleanAddr.startsWith('I')) inputs.add(cleanAddr)
        else if (cleanAddr.startsWith('Q')) outputs.add(cleanAddr)
        else if (cleanAddr.startsWith('M')) memory.add(cleanAddr)
        else if (cleanAddr.startsWith('T')) {
          timers.set(cleanAddr, el.preset || 1000)
        } else if (cleanAddr.startsWith('C')) {
          counters.set(cleanAddr, el.preset || 10)
        }
      }
    })
  })

  // Input section
  if (inputs.size > 0) {
    lines.push('VAR_INPUT')
    Array.from(inputs).sort().forEach(addr => {
      const ioInfo = program.ioMap.find(io => io.address === addr)
      lines.push(`  "${addr.replace('.', '_')}" : Bool; // ${ioInfo?.description || 'Input'}`)
    })
    lines.push('END_VAR')
    lines.push('')
  }

  // Output section
  if (outputs.size > 0) {
    lines.push('VAR_OUTPUT')
    Array.from(outputs).sort().forEach(addr => {
      const ioInfo = program.ioMap.find(io => io.address === addr)
      lines.push(`  "${addr.replace('.', '_')}" : Bool; // ${ioInfo?.description || 'Output'}`)
    })
    lines.push('END_VAR')
    lines.push('')
  }

  // Static section (internal memory, timers, counters)
  if (memory.size > 0 || timers.size > 0 || counters.size > 0) {
    lines.push('VAR')
    Array.from(memory).sort().forEach(addr => {
      const ioInfo = program.ioMap.find(io => io.address === addr)
      lines.push(`  "${addr.replace('.', '_')}" : Bool; // ${ioInfo?.description || 'Memory'}`)
    })
    Array.from(timers.keys()).sort().forEach(addr => {
      const ioInfo = program.ioMap.find(io => io.address === addr)
      lines.push(`  "${addr}" : IEC_Timer; // ${ioInfo?.description || 'Timer'}`)
    })
    Array.from(counters.keys()).sort().forEach(addr => {
      const ioInfo = program.ioMap.find(io => io.address === addr)
      lines.push(`  "${addr}" : IEC_Counter; // ${ioInfo?.description || 'Counter'}`)
    })
    lines.push('END_VAR')
    lines.push('')
  }

  lines.push('BEGIN')
  lines.push('')

  // Program body
  program.networks.forEach((network, idx) => {
    lines.push(`// Network ${idx + 1}${network.label ? ': ' + network.label : ''}`)
    const stCode = convertRungToStructuredText(network)
    if (stCode.trim()) {
      // Replace address formatting for Siemens
      const scl = stCode.replace(/([IQMT]\d+_\d+)/g, '"$1"')
      lines.push(scl)
    }
    lines.push('')
  })

  lines.push('END_FUNCTION_BLOCK')

  return lines.join('\n')
}

/**
 * Export ladder program to Rockwell Logix Structured Text
 */
export function exportToRockwellST(program: LadderProgram): string {
  const lines: string[] = []

  lines.push('(* ========================================= *)')
  lines.push('(* Rockwell Logix Structured Text          *)')
  lines.push('(* Studio 5000 / ControlLogix / CompactLogix *)')
  lines.push('(* Generated by PLCVibe                     *)')
  lines.push('(* ========================================= *)')
  lines.push('')

  // Collect variables
  const inputs = new Set<string>()
  const outputs = new Set<string>()
  const memory = new Set<string>()
  const timers = new Map<string, number>()

  program.networks.forEach(network => {
    network.elements.forEach(el => {
      if (el.address) {
        const cleanAddr = el.address.replace(/[\[\]\/\s]/g, '').split('.')[0]
        if (cleanAddr.startsWith('I')) inputs.add(cleanAddr)
        else if (cleanAddr.startsWith('Q')) outputs.add(cleanAddr)
        else if (cleanAddr.startsWith('M')) memory.add(cleanAddr)
        else if (cleanAddr.startsWith('T')) {
          timers.set(cleanAddr, el.preset || 1000)
        }
      }
    })
  })

  lines.push('(* Tag Definitions - Create these tags in Controller Tags *)')
  lines.push('(*')
  Array.from(inputs).sort().forEach(addr => {
    const ioInfo = program.ioMap.find(io => io.address === addr)
    lines.push(`  ${addr.replace('.', '_')} : BOOL; (* ${ioInfo?.description || 'Input'} *)`)
  })
  Array.from(outputs).sort().forEach(addr => {
    const ioInfo = program.ioMap.find(io => io.address === addr)
    lines.push(`  ${addr.replace('.', '_')} : BOOL; (* ${ioInfo?.description || 'Output'} *)`)
  })
  Array.from(memory).sort().forEach(addr => {
    const ioInfo = program.ioMap.find(io => io.address === addr)
    lines.push(`  ${addr.replace('.', '_')} : BOOL; (* ${ioInfo?.description || 'Memory'} *)`)
  })
  Array.from(timers.keys()).sort().forEach(addr => {
    const ioInfo = program.ioMap.find(io => io.address === addr)
    const preset = timers.get(addr) || 1000
    lines.push(`  ${addr} : TIMER; (* ${ioInfo?.description || 'Timer'}, Preset: ${preset}ms *)`)
  })
  lines.push('*)')
  lines.push('')

  // Program body
  program.networks.forEach((network, idx) => {
    lines.push(`(* Network ${idx + 1}${network.label ? ': ' + network.label : ''} *)`)
    const stCode = convertRungToRockwellST(network)
    if (stCode.trim()) {
      lines.push(stCode)
    }
    lines.push('')
  })

  return lines.join('\n')
}

function convertRungToRockwellST(rung: LadderRung): string {
  const elements = rung.elements
  const conditions: string[] = []
  const outputs: Array<{type: string, address: string, preset?: number, operand1?: string, operand2?: string, value?: number}> = []

  elements.forEach(el => {
    switch (el.type) {
      case 'contact-no':
        if (el.address!.includes('.DN')) {
          const timerAddr = el.address!.replace(/[\[\]\s]/g, '').split('.')[0]
          conditions.push(`${timerAddr}.DN`)
        } else {
          conditions.push(el.address!.replace('.', '_'))
        }
        break

      case 'contact-nc':
        if (el.address!.includes('.DN')) {
          const timerAddr = el.address!.replace(/[\[\]\/\s]/g, '').split('.')[0]
          conditions.push(`NOT ${timerAddr}.DN`)
        } else {
          conditions.push(`NOT ${el.address!.replace('.', '_')}`)
        }
        break

      case 'coil':
      case 'coil-set':
      case 'coil-reset':
        outputs.push({type: el.type, address: el.address!})
        break

      case 'timer':
        outputs.push({type: 'timer', address: el.address!, preset: el.preset})
        break

      // Comparison operators
      case 'compare-gt':
      case 'compare-lt':
      case 'compare-eq':
      case 'compare-ge':
      case 'compare-le':
      case 'compare-ne':
        if (el.operand1 && el.value !== undefined) {
          let op = '?'
          switch (el.type) {
            case 'compare-gt': op = '>'; break
            case 'compare-lt': op = '<'; break
            case 'compare-eq': op = '='; break
            case 'compare-ge': op = '>='; break
            case 'compare-le': op = '<='; break
            case 'compare-ne': op = '<>'; break
          }
          conditions.push(`${el.operand1.replace('.', '_')} ${op} ${el.value}`)
        }
        break

      // Math operations
      case 'math-add':
      case 'math-sub':
      case 'math-mul':
      case 'math-div':
      case 'move':
        outputs.push({
          type: el.type,
          address: el.result || '',
          operand1: el.operand1,
          operand2: el.operand2,
          value: el.value
        })
        break
    }
  })

  const lines: string[] = []
  const enableCondition = conditions.length > 0 ? conditions.join(' AND ') : '1'

  // Timers in Rockwell use TON instruction
  outputs.forEach(output => {
    if (output.type === 'timer') {
      lines.push(`TON(${output.address}, ${enableCondition}, ${output.preset});`)
    }
  })

  // Coil outputs
  const coilOutputs = outputs.filter(o => o.type === 'coil' || o.type === 'coil-set' || o.type === 'coil-reset')

  if (coilOutputs.length > 0 && conditions.length > 0) {
    lines.push(`IF ${enableCondition} THEN`)
    coilOutputs.forEach(output => {
      const addr = output.address.replace('.', '_')
      if (output.type === 'coil') {
        lines.push(`  ${addr} := 1;`)
      } else if (output.type === 'coil-set') {
        lines.push(`  ${addr} := 1; (* SET *)`)
      } else if (output.type === 'coil-reset') {
        lines.push(`  ${addr} := 0; (* RESET *)`)
      }
    })

    if (coilOutputs.some(o => o.type === 'coil')) {
      lines.push('ELSE')
      coilOutputs.forEach(output => {
        if (output.type === 'coil') {
          lines.push(`  ${output.address.replace('.', '_')} := 0;`)
        }
      })
    }

    lines.push('END_IF;')
  }

  // Math operations for Rockwell
  const mathOutputs = outputs.filter(o => o.type === 'math-add' || o.type === 'math-sub' || o.type === 'math-mul' || o.type === 'math-div' || o.type === 'move')

  if (mathOutputs.length > 0 && conditions.length > 0) {
    if (coilOutputs.length === 0) {
      lines.push(`IF ${enableCondition} THEN`)
      mathOutputs.forEach(output => {
        const mathCode = generateMathOperationCode(output)
        if (mathCode) lines.push(`  ${mathCode}`)
      })
      lines.push('END_IF;')
    } else {
      // Add to existing IF block
      const lastIfIdx = lines.lastIndexOf('END_IF;')
      if (lastIfIdx !== -1) {
        mathOutputs.forEach(output => {
          const mathCode = generateMathOperationCode(output)
          if (mathCode) lines.splice(lastIfIdx, 0, `  ${mathCode}`)
        })
      }
    }
  } else if (mathOutputs.length > 0) {
    mathOutputs.forEach(output => {
      const mathCode = generateMathOperationCode(output)
      if (mathCode) lines.push(mathCode)
    })
  }

  return lines.join('\n')
}

/**
 * Main export function that routes to specific format
 */
export function exportLadderProgram(
  program: LadderProgram,
  format: ExportFormat = 'structured-text'
): string {
  switch (format) {
    case 'structured-text':
      return exportToStructuredText(program)
    case 'instruction-list':
      return exportToInstructionList(program)
    case 'siemens-scl':
      return exportToSiemensSCL(program)
    case 'rockwell-st':
      return exportToRockwellST(program)
    case 'text':
    default:
      // Return original text format (handled by serializer)
      return ''
  }
}
