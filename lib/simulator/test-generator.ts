/**
 * Test Scenario Generator
 *
 * 사용자 요청과 래더 프로그램을 분석하여
 * 자동으로 테스트 시나리오를 생성합니다.
 */

import type { LadderProgram } from '@/lib/ladder/parser'

export interface TestStep {
  type: 'set_input' | 'wait' | 'check_output' | 'check_timer'
  address?: string
  value?: boolean
  duration?: number // ms
  expected?: boolean | { elapsed: number; done: boolean }
  description: string
}

export interface TestScenario {
  id: string
  name: string
  description: string
  steps: TestStep[]
  expectedOutcome: string
  category: 'basic' | 'timing' | 'safety' | 'sequence'
}

export interface TestGenerationResult {
  scenarios: TestScenario[]
  autoGenerated: boolean
  confidence: 'high' | 'medium' | 'low'
}

/**
 * 사용자 요청과 프로그램을 분석하여 테스트 시나리오 생성
 */
export function generateTestScenarios(
  userRequest: string,
  program: LadderProgram
): TestGenerationResult {
  const scenarios: TestScenario[] = []

  // 1. 기본 시나리오: 모든 입력이 꺼져있을 때 (초기 상태)
  scenarios.push(createInitialStateScenario(program))

  // 2. 사용자 요청 분석 기반 시나리오
  const requestScenarios = analyzeUserRequest(userRequest, program)
  scenarios.push(...requestScenarios)

  // 3. 프로그램 분석 기반 시나리오
  const programScenarios = analyzeProgramStructure(program)
  scenarios.push(...programScenarios)

  // 4. 안전 시나리오 (E-Stop 등)
  const safetyScenarios = generateSafetyScenarios(program)
  scenarios.push(...safetyScenarios)

  return {
    scenarios,
    autoGenerated: true,
    confidence: requestScenarios.length > 0 ? 'high' : 'medium'
  }
}

/**
 * 초기 상태 시나리오: 모든 입력 꺼짐 → 모든 출력 꺼져야 함
 */
function createInitialStateScenario(program: LadderProgram): TestScenario {
  const steps: TestStep[] = []

  // 모든 입력을 false로 설정
  const inputs = program.ioMap.filter(io => io.type === 'DI')
  inputs.forEach(input => {
    steps.push({
      type: 'set_input',
      address: input.address,
      value: false,
      description: `Turn off ${input.name}`
    })
  })

  // 100ms 대기
  steps.push({
    type: 'wait',
    duration: 100,
    description: 'Wait for scan cycle'
  })

  // 모든 출력이 false인지 확인
  const outputs = program.ioMap.filter(io => io.type === 'DO')
  outputs.forEach(output => {
    steps.push({
      type: 'check_output',
      address: output.address,
      expected: false,
      description: `Verify ${output.name} is OFF`
    })
  })

  return {
    id: 'initial_state',
    name: 'Initial State Test',
    description: 'All inputs OFF → All outputs should be OFF',
    steps,
    expectedOutcome: 'All outputs remain OFF when no inputs are active',
    category: 'basic'
  }
}

/**
 * 사용자 요청 분석하여 시나리오 생성
 */
function analyzeUserRequest(
  userRequest: string,
  program: LadderProgram
): TestScenario[] {
  const scenarios: TestScenario[] = []
  const lowerRequest = userRequest.toLowerCase()

  // 패턴 1: "버튼 누르면 ... 켜진다"
  if (lowerRequest.includes('버튼') || lowerRequest.includes('button')) {
    scenarios.push(createButtonPressScenario(program, userRequest))
  }

  // 패턴 2: "타이머" or "초 후" - 타이밍 관련
  if (lowerRequest.includes('타이머') || lowerRequest.includes('timer') ||
      lowerRequest.match(/\d+초/) || lowerRequest.match(/\d+\s*sec/)) {
    scenarios.push(createTimerScenario(program, userRequest))
  }

  // 패턴 3: "정지" or "stop" - 정지 기능
  if (lowerRequest.includes('정지') || lowerRequest.includes('stop')) {
    scenarios.push(createStopScenario(program, userRequest))
  }

  // 패턴 4: "자기유지" or "seal-in" or "latch"
  if (lowerRequest.includes('자기유지') || lowerRequest.includes('seal') ||
      lowerRequest.includes('latch')) {
    scenarios.push(createSealInScenario(program, userRequest))
  }

  return scenarios
}

/**
 * 버튼 누름 시나리오
 */
function createButtonPressScenario(
  program: LadderProgram,
  userRequest: string
): TestScenario {
  const steps: TestStep[] = []

  // 시작 버튼 찾기
  const startButton = program.ioMap.find(io =>
    io.type === 'DI' && (
      io.name.toLowerCase().includes('start') ||
      io.name.toLowerCase().includes('시작')
    )
  )

  // 출력 찾기
  const output = program.ioMap.find(io => io.type === 'DO')

  if (startButton && output) {
    // 1. 시작 버튼 누름
    steps.push({
      type: 'set_input',
      address: startButton.address,
      value: true,
      description: `Press ${startButton.name}`
    })

    // 2. 대기
    steps.push({
      type: 'wait',
      duration: 100,
      description: 'Wait for logic execution'
    })

    // 3. 출력 확인
    steps.push({
      type: 'check_output',
      address: output.address,
      expected: true,
      description: `Verify ${output.name} turns ON`
    })
  }

  return {
    id: 'button_press',
    name: 'Button Press Test',
    description: `Press start button → Output should activate`,
    steps,
    expectedOutcome: 'Output activates when start button is pressed',
    category: 'basic'
  }
}

/**
 * 타이머 시나리오
 */
function createTimerScenario(
  program: LadderProgram,
  userRequest: string
): TestScenario {
  const steps: TestStep[] = []

  // 타이머 시간 추출 (예: "5초" → 5000ms)
  const timeMatch = userRequest.match(/(\d+)\s*초/) || userRequest.match(/(\d+)\s*sec/)
  const timerDelay = timeMatch ? parseInt(timeMatch[1]) * 1000 : 5000

  // 시작 입력 찾기
  const startInput = program.ioMap.find(io =>
    io.type === 'DI' && (
      io.name.toLowerCase().includes('start') ||
      io.name.toLowerCase().includes('시작')
    )
  )

  // 출력 찾기
  const output = program.ioMap.find(io => io.type === 'DO')

  // 타이머 찾기 (프로그램에서)
  const timerElement = program.networks
    .flatMap(n => n.elements)
    .find(e => e.type === 'timer')

  if (startInput && output) {
    // 1. 입력 활성화
    steps.push({
      type: 'set_input',
      address: startInput.address,
      value: true,
      description: `Activate ${startInput.name}`
    })

    // 2. 짧은 대기 (타이머 시작 전)
    steps.push({
      type: 'wait',
      duration: 100,
      description: 'Wait for timer to start'
    })

    // 3. 출력이 아직 OFF인지 확인
    steps.push({
      type: 'check_output',
      address: output.address,
      expected: false,
      description: `Verify ${output.name} is still OFF (before delay)`
    })

    // 4. 타이머 딜레이만큼 대기
    const actualDelay = timerElement?.preset || timerDelay
    steps.push({
      type: 'wait',
      duration: actualDelay + 200, // 여유있게
      description: `Wait for timer delay (${actualDelay}ms)`
    })

    // 5. 출력이 ON인지 확인
    steps.push({
      type: 'check_output',
      address: output.address,
      expected: true,
      description: `Verify ${output.name} turns ON after delay`
    })
  }

  return {
    id: 'timer_delay',
    name: 'Timer Delay Test',
    description: `Input ON → Wait ${timerDelay}ms → Output should turn ON`,
    steps,
    expectedOutcome: `Output activates after ${timerDelay}ms delay`,
    category: 'timing'
  }
}

/**
 * 정지 시나리오
 */
function createStopScenario(
  program: LadderProgram,
  userRequest: string
): TestScenario {
  const steps: TestStep[] = []

  // 정지 버튼 찾기
  const stopButton = program.ioMap.find(io =>
    io.type === 'DI' && (
      io.name.toLowerCase().includes('stop') ||
      io.name.toLowerCase().includes('정지')
    )
  )

  // 시작 버튼 찾기
  const startButton = program.ioMap.find(io =>
    io.type === 'DI' && (
      io.name.toLowerCase().includes('start') ||
      io.name.toLowerCase().includes('시작')
    )
  )

  // 출력 찾기
  const output = program.ioMap.find(io => io.type === 'DO')

  if (startButton && stopButton && output) {
    // 1. 시작 버튼으로 출력 켜기
    steps.push({
      type: 'set_input',
      address: startButton.address,
      value: true,
      description: `Press ${startButton.name}`
    })

    steps.push({
      type: 'wait',
      duration: 100,
      description: 'Wait for activation'
    })

    steps.push({
      type: 'check_output',
      address: output.address,
      expected: true,
      description: `Verify ${output.name} is ON`
    })

    // 2. 정지 버튼 누름
    steps.push({
      type: 'set_input',
      address: stopButton.address,
      value: true,
      description: `Press ${stopButton.name}`
    })

    steps.push({
      type: 'wait',
      duration: 100,
      description: 'Wait for stop action'
    })

    // 3. 출력이 OFF인지 확인
    steps.push({
      type: 'check_output',
      address: output.address,
      expected: false,
      description: `Verify ${output.name} turns OFF`
    })
  }

  return {
    id: 'stop_function',
    name: 'Stop Function Test',
    description: 'Start → Run → Stop → Output should turn OFF',
    steps,
    expectedOutcome: 'Output turns OFF when stop button is pressed',
    category: 'basic'
  }
}

/**
 * 자기유지 시나리오
 */
function createSealInScenario(
  program: LadderProgram,
  userRequest: string
): TestScenario {
  const steps: TestStep[] = []

  const startButton = program.ioMap.find(io =>
    io.type === 'DI' && (
      io.name.toLowerCase().includes('start') ||
      io.name.toLowerCase().includes('시작')
    )
  )

  const output = program.ioMap.find(io => io.type === 'DO')

  if (startButton && output) {
    // 1. 버튼 누름
    steps.push({
      type: 'set_input',
      address: startButton.address,
      value: true,
      description: `Press ${startButton.name}`
    })

    steps.push({
      type: 'wait',
      duration: 100,
      description: 'Wait for activation'
    })

    steps.push({
      type: 'check_output',
      address: output.address,
      expected: true,
      description: `Verify ${output.name} turns ON`
    })

    // 2. 버튼 뗌 (자기유지 테스트)
    steps.push({
      type: 'set_input',
      address: startButton.address,
      value: false,
      description: `Release ${startButton.name}`
    })

    steps.push({
      type: 'wait',
      duration: 100,
      description: 'Wait after release'
    })

    // 3. 출력이 여전히 ON인지 확인 (자기유지)
    steps.push({
      type: 'check_output',
      address: output.address,
      expected: true,
      description: `Verify ${output.name} stays ON (seal-in)`
    })
  }

  return {
    id: 'seal_in',
    name: 'Seal-in Circuit Test',
    description: 'Press button → Release → Output should stay ON',
    steps,
    expectedOutcome: 'Output remains ON after button is released (latched)',
    category: 'sequence'
  }
}

/**
 * 프로그램 구조 분석하여 시나리오 생성
 */
function analyzeProgramStructure(program: LadderProgram): TestScenario[] {
  const scenarios: TestScenario[] = []

  // 각 네트워크별 간단한 테스트
  program.networks.forEach((network, idx) => {
    const inputs = network.elements.filter(e =>
      e.type === 'contact-no' || e.type === 'contact-nc'
    )
    const outputs = network.elements.filter(e => e.type === 'coil')

    if (inputs.length > 0 && outputs.length > 0) {
      // 이 네트워크의 기본 동작 테스트
      const steps: TestStep[] = []

      // NO 컨택트 활성화
      inputs.filter(i => i.type === 'contact-no').forEach(input => {
        steps.push({
          type: 'set_input',
          address: input.address!,
          value: true,
          description: `Activate ${input.address}`
        })
      })

      // NC 컨택트 비활성화 (NC는 반대로)
      inputs.filter(i => i.type === 'contact-nc').forEach(input => {
        steps.push({
          type: 'set_input',
          address: input.address!,
          value: false,
          description: `Keep ${input.address} OFF (for NC contact)`
        })
      })

      steps.push({
        type: 'wait',
        duration: 100,
        description: 'Wait for execution'
      })

      // 출력 확인
      outputs.forEach(output => {
        steps.push({
          type: 'check_output',
          address: output.address!,
          expected: true,
          description: `Verify ${output.address} turns ON`
        })
      })

      scenarios.push({
        id: `network_${network.id}`,
        name: `Network ${network.id} Test`,
        description: network.label || `Test network ${network.id}`,
        steps,
        expectedOutcome: `Network ${network.id} executes correctly`,
        category: 'basic'
      })
    }
  })

  return scenarios
}

/**
 * 안전 관련 시나리오 생성
 */
function generateSafetyScenarios(program: LadderProgram): TestScenario[] {
  const scenarios: TestScenario[] = []

  // E-Stop 찾기
  const eStop = program.ioMap.find(io =>
    io.type === 'DI' && (
      io.name.toLowerCase().includes('stop') ||
      io.name.toLowerCase().includes('emergency') ||
      io.name.toLowerCase().includes('e-stop')
    )
  )

  const outputs = program.ioMap.filter(io => io.type === 'DO')

  if (eStop && outputs.length > 0) {
    const steps: TestStep[] = []

    // E-Stop 활성화
    steps.push({
      type: 'set_input',
      address: eStop.address,
      value: true,
      description: `Activate ${eStop.name}`
    })

    steps.push({
      type: 'wait',
      duration: 100,
      description: 'Wait for safety logic'
    })

    // 모든 출력이 OFF인지 확인
    outputs.forEach(output => {
      steps.push({
        type: 'check_output',
        address: output.address,
        expected: false,
        description: `Verify ${output.name} is OFF (safety)`
      })
    })

    scenarios.push({
      id: 'emergency_stop',
      name: 'Emergency Stop Test',
      description: 'E-Stop activated → All outputs should turn OFF',
      steps,
      expectedOutcome: 'All outputs turn OFF when E-Stop is activated',
      category: 'safety'
    })
  }

  return scenarios
}