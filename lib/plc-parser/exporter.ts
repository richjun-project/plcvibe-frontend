// PLC File Exporter - converts ladder logic to various PLC formats

import type { LadderProgram } from '@/lib/ladder/parser'

export interface ExportOptions {
  format: 'siemens-s7' | 'allen-bradley-l5x' | 'mitsubishi-gx' | 'text'
  filename: string
  projectName?: string
}

export function exportToFile(program: LadderProgram, options: ExportOptions): Blob {
  let content: string

  switch (options.format) {
    case 'siemens-s7':
      content = exportToSiemensS7(program, options.projectName || 'PLC_Project')
      return new Blob([content], { type: 'text/plain' })

    case 'allen-bradley-l5x':
      content = exportToAllenBradleyL5X(program, options.projectName || 'PLC_Project')
      return new Blob([content], { type: 'application/xml' })

    case 'mitsubishi-gx':
      content = exportToMitsubishiGX(program)
      return new Blob([content], { type: 'text/plain' })

    case 'text':
    default:
      content = exportToText(program)
      return new Blob([content], { type: 'text/plain' })
  }
}

function exportToSiemensS7(program: LadderProgram, projectName: string): string {
  let output = `// Siemens S7 Export - ${projectName}\n`
  output += `// Generated by PLC Vibe\n`
  output += `// Date: ${new Date().toISOString()}\n\n`

  output += `ORGANIZATION_BLOCK OB1\n`
  output += `TITLE = 'Main Program Cycle'\n`
  output += `VERSION : 0.1\n\n`
  output += `BEGIN\n\n`

  program.networks.forEach((network) => {
    output += `  // ${network.label || `Network ${network.id}`}\n`
    output += `  `

    network.elements.forEach((element, idx) => {
      if (element.type === 'contact-no') {
        output += `A "${element.address}"`
      } else if (element.type === 'contact-nc') {
        output += `AN "${element.address}"`
      } else if (element.type === 'coil') {
        output += `= "${element.address}"`
      } else if (element.type === 'timer') {
        output += `TON T_${element.address}, ${element.preset}`
      }

      if (idx < network.elements.length - 1) {
        output += '\n  '
      }
    })

    output += '\n\n'
  })

  output += `END_ORGANIZATION_BLOCK\n`

  return output
}

function exportToAllenBradleyL5X(program: LadderProgram, projectName: string): string {
  let xml = `<?xml version="1.0" encoding="UTF-8"?>\n`
  xml += `<RSLogix5000Content SchemaRevision="1.0">\n`
  xml += `  <Controller Use="Target" Name="${projectName}">\n`
  xml += `    <Programs>\n`
  xml += `      <Program Name="MainProgram" Type="Normal">\n`
  xml += `        <Routines>\n`
  xml += `          <Routine Name="MainRoutine" Type="RLL">\n`
  xml += `            <RLLContent>\n`

  program.networks.forEach((network) => {
    xml += `              <Rung Number="${network.id}" Type="N">\n`
    xml += `                <Comment>${network.label || ''}</Comment>\n`
    xml += `                <Text><![CDATA[`

    network.elements.forEach((element) => {
      if (element.type === 'contact-no') {
        xml += `XIC(${element.address})`
      } else if (element.type === 'contact-nc') {
        xml += `XIO(${element.address})`
      } else if (element.type === 'coil') {
        xml += `OTE(${element.address})`
      }
    })

    xml += `]]></Text>\n`
    xml += `              </Rung>\n`
  })

  xml += `            </RLLContent>\n`
  xml += `          </Routine>\n`
  xml += `        </Routines>\n`
  xml += `      </Program>\n`
  xml += `    </Programs>\n`
  xml += `  </Controller>\n`
  xml += `</RSLogix5000Content>\n`

  return xml
}

function exportToMitsubishiGX(program: LadderProgram): string {
  let output = `*\n`
  output += `* Mitsubishi GX Works Export\n`
  output += `* Generated by PLC Vibe\n`
  output += `*\n\n`

  program.networks.forEach((network) => {
    output += `* ${network.label || `Network ${network.id}`}\n`

    network.elements.forEach((element) => {
      if (element.type === 'contact-no') {
        output += `LD ${element.address}\n`
      } else if (element.type === 'contact-nc') {
        output += `LDI ${element.address}\n`
      } else if (element.type === 'coil') {
        output += `OUT ${element.address}\n`
      }
    })

    output += '\n'
  })

  output += `END\n`

  return output
}

function exportToText(program: LadderProgram): string {
  let output = `PLC Ladder Logic Program\n`
  output += `Generated by PLC Vibe\n`
  output += `Date: ${new Date().toISOString()}\n`
  output += `${'='.repeat(60)}\n\n`

  // I/O Map
  if (program.ioMap.length > 0) {
    output += `I/O MAPPING:\n`
    output += `${'-'.repeat(60)}\n`
    program.ioMap.forEach((io) => {
      output += `${io.address.padEnd(10)} - ${io.name} (${io.type})\n`
    })
    output += `\n`
  }

  // Ladder Logic
  output += `LADDER LOGIC:\n`
  output += `${'-'.repeat(60)}\n\n`

  program.networks.forEach((network) => {
    output += `Network ${network.id}: ${network.label || ''}\n`
    output += `|--`

    network.elements.forEach((element) => {
      if (element.type === 'contact-no') {
        output += `[ ${element.address} ]--`
      } else if (element.type === 'contact-nc') {
        output += `[/${element.address} ]--`
      } else if (element.type === 'coil') {
        output += `( ${element.address} )--`
      } else if (element.type === 'timer') {
        output += `[TON ${element.address}, ${element.preset}ms]--`
      }
    })

    output += `|\n\n`
  })

  return output
}

export function downloadFile(blob: Blob, filename: string) {
  const url = URL.createObjectURL(blob)
  const a = document.createElement('a')
  a.href = url
  a.download = filename
  document.body.appendChild(a)
  a.click()
  document.body.removeChild(a)
  URL.revokeObjectURL(url)
}